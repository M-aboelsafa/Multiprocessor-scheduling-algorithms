#include <iostream>
using namespace std;
#include <bits/stdc++.h>
#define el '\n'
using namespace std;
int N = 100000;
vector<vector<string>> output(N, vector<string>(4));

// priority_queue<process,compare>
struct process
{
    string process_name;
    int process_idx; // index in the array
    int arrive_time;
    int turn_around_time;
    int complete_time;
    int time_consumed; // current phase take kam second
    int n_phases;      //  kam phase
    int phase_idx;
    int last_processor;             // last processor work on
    vector<pair<int, bool>> phases; //
    int state;                      // current state
    int priority;
    int current_brust_time;
};

void Input(int n, process processes[])
{
    string y;
    int x;
    for (int i = 0; i < n; i++)
    {
        cin >> processes[i].process_name;
        cin >> processes[i].n_phases;
        cin >> processes[i].arrive_time;
        processes[i].phases.resize(processes[i].n_phases);
        for (int j = 0; j < processes[i].n_phases; j++)
        {
            cin >> processes[i].phases[j].first;
            cin >> y;
            if (y == "I/O")
            {
                processes[i].phases[j].second = 0;
            }
            if (y == "EXE")
            {
                processes[i].phases[j].second = 1;
            }
        }
        processes[i].last_processor = -1;
        processes[i].phase_idx = 0;
        processes[i].time_consumed = 0;
        processes[i].process_idx = i;
        processes[i].complete_time = 0;
        processes[i].turn_around_time = 0;
        processes[i].state=1;
    }
}
struct CompareProcess {
    const process *data;
    CompareProcess(const process* d) : data(d) {}
    bool operator()(int a, int b) const {
        return (data[a].current_brust_time - data[a].time_consumed) > (data[b].current_brust_time - data[a].time_consumed);
    }
};
struct CompareProcesspriority {
    const process *data;
    CompareProcesspriority(const process* d) : data(d) {}
    bool operator()(int a, int b) const {
        return data[a].priority > data[b].priority;
    }
};

void print(int endtime)
{
    for (int j = 0; j < 4; j++) // no of processors
    {
        cout << "processor " << j + 1 << " : ";
        for (int i = 0; i < endtime; i++) // all seconds
        {
            cout << output[i][j] << "|";
        }
        cout << output[endtime][j] << "\n";
    }
}
/*void IO_handler(int n, process processes[], queue<int> &my_queue, int &finised_processes, int t)
{
    for (int i = 0; i < n; i++)
    {
        if (processes[i].state == 0) // state IO
        {
            // cout << "IO handler " << i << "\n";
            processes[i].time_consumed++;
            if (processes[i].time_consumed == processes[i].current_brust_time) // IO Finished
            {
                processes[i].time_consumed = 0;
                processes[i].phase_idx++;
                if (processes[i].phase_idx < processes[i].n_phases)
                {
                    processes[i].state = processes[i].phases[processes[i].phase_idx].second;
                    processes[i].current_brust_time = processes[i].phases[processes[i].phase_idx].first;
                    if (processes[i].state)
                    {
                        // cout << "PUSH\n";
                        my_queue.push(i);
                    }
                }
                else
                {
                    // cout << "DONE\n";
                    processes[i].state = 2;
                    (finised_processes)++;
                    processes[i].complete_time = t;
                    processes[i].turn_around_time = t - processes[i].arrive_time;
                }
            }
        }
    }
}*/
void IO_handler_bypq(int n, process processes[], priority_queue<int,vector<int>,CompareProcess> &my_queue, int &finised_processes, int t)
{
    for (int i = 0; i < n; i++)
    {
        if (processes[i].state == 0) // state IO
        {
            // cout << "IO handler " << i << "\n";
            processes[i].time_consumed++;
            if (processes[i].time_consumed == processes[i].current_brust_time) // IO Finished
            {
                processes[i].time_consumed = 0;
                processes[i].phase_idx++;
                if (processes[i].phase_idx < processes[i].n_phases)
                {
                    processes[i].state = processes[i].phases[processes[i].phase_idx].second;
                    processes[i].current_brust_time = processes[i].phases[processes[i].phase_idx].first;
                    if (processes[i].state)
                    {
                        // cout << "PUSH\n";
                        my_queue.push(i);
                    }
                }
                else
                {
                    // cout << "DONE\n";
                    processes[i].state = 2;
                    (finised_processes)++;
                    processes[i].complete_time = t;
                    processes[i].turn_around_time = t - processes[i].arrive_time;
                }
            }
        }
    }
}

void match_prefrences(int processor[], int WillGoToTheQ[], process processes[])
{
    // First loop: Assign processes to processors if the processor is available
    for (int i = 0; i < 4; i++)
    {
        if (WillGoToTheQ[i] != -1 && processor[processes[WillGoToTheQ[i]].last_processor] == -1)
        {
            processor[processes[WillGoToTheQ[i]].last_processor] = WillGoToTheQ[i];
            WillGoToTheQ[i] = -1;
        }
    }

    // Second loop: Assign processes to the first available processor
    for (int i = 0; i < 4; i++)
    {
        if (WillGoToTheQ[i] != -1)
        {
            for (int j = 0; j < 4; j++)
            {
                if (processor[j] == -1)
                {
                    processor[j] = WillGoToTheQ[i];
                    processes[WillGoToTheQ[i]].last_processor = j;
                    WillGoToTheQ[i] = -1;
                    break; // Break out of the loop after assigning the process
                }
            }
        }
    }
}

/*void FCFS (int size , process processes [])
{
    int finished_processes=0,processor[4],WillGoToTheQ[4],i=0,pr;
    memset(processor,-1,sizeof processor);
    memset(WillGoToTheQ,-1,sizeof WillGoToTheQ);
    queue<int>waiting;
    for(int t=0;;t++)
    {
        int idx_p=0;
        for (idx_p = 0; idx_p < 4 && i < size && processes[i].arrive_time <= t; ++idx_p) // if processor is ideal and processes
        {
            if (processor[idx_p] == -1)
            {
                processor[idx_p] = i;
                processes[i].current_brust_time = processes[i].phases[processes[i].phase_idx].first;
                processes[i].state = processes[i].phases[processes[i].phase_idx].second;
                processes[i].last_processor = idx_p;
                i++;
            }
        }
        while(i<size && processes[i].arrive_time <=t ) // processes arrived but there is no place at cpu so it will go in waiting queue
        {
            waiting.push(i);
            processes[i].state = processes[i].phases[processes[i].phase_idx].second;
            processes[i].current_brust_time = processes[i].phases[processes[i].phase_idx].first;
            i++;
        }
        for(idx_p =0 ;idx_p<4;idx_p++)
        {
            if(processor[idx_p]==-1) // means that , that processor is ideal
            {
                output[t][idx_p]="i";
                if(!waiting.empty())
                {
                    WillGoToTheQ[idx_p]=waiting.front();
                    waiting.pop();
                }
                continue;
            }
            pr = processor[idx_p];  // index of the process in the processor
            output[t][idx_p]=processes[pr].process_name;
            processes[pr].time_consumed++;
            if(processes[pr].time_consumed == processes[pr].current_brust_time) // proceses finished exec
            {
                processes[pr].phase_idx++;
                processes[pr].time_consumed=0;
                if(processes[pr].phase_idx < processes[pr].n_phases) // still want more ?
                {
                    processes[pr].state = processes[pr].phases[processes[pr].phase_idx].second;
                    processes[pr].current_brust_time = processes[pr].phases[processes[pr].phase_idx].first;
                }
                else //process finished
                {
                    finished_processes++;
                    processes[pr].state=2;
                    processes[pr].complete_time=t;
                    processes[pr].turn_around_time = t - processes[pr].arrive_time;
                }
                if (!waiting.empty())
                {
                    WillGoToTheQ[idx_p] = waiting.front();
                    waiting.pop();
                }
                processor[idx_p]=-1;
            }

        }
        match_prefrences(processor,WillGoToTheQ,processes);
        IO_handler(size,processes,waiting,finished_processes,t);

        if (finished_processes == size)
        {
            print(t);
            return;
        }

    }
}*/


bool comparedByBurst(const process& p1,const process& p2) //ascending order
{
    if(p1.arrive_time == p2.arrive_time)
        return p1.phases[0].first <p2.phases[0].first;
    else
        return p1.arrive_time < p2.arrive_time;
}


bool comareByPriority(const process& p1,const process& p2) // ascending order
{
    return p1.priority < p2.priority;

}

void SJF(int size,process processes [] )
{
    sort(processes,processes+size, comparedByBurst);
    int finished_processes=0,processor[4],WillGoToTheQ[4],i=0,pr;
    memset(processor,-1,sizeof processor);
    memset(WillGoToTheQ,-1,sizeof WillGoToTheQ);
    CompareProcess cmp (processes);
    priority_queue<int,vector<int>,CompareProcess>waiting(cmp);
    for(int t=0;;t++)
    {
        int idx_p=0;
        for (idx_p = 0; idx_p < 4 && i < size && processes[i].arrive_time <= t; ++idx_p) // if processor is ideal and processes
        {
            if (processor[idx_p] == -1)
            {
                processor[idx_p] = i;
                processes[i].current_brust_time = processes[i].phases[processes[i].phase_idx].first;
                processes[i].state = processes[i].phases[processes[i].phase_idx].second;
                processes[i].last_processor = idx_p;
                i++;
            }
        }
        while(i<size && processes[i].arrive_time <=t ) // processes arrived but there is no place at cpu so it will go in waiting queue
        {
            processes[i].state = processes[i].phases[processes[i].phase_idx].second;
            processes[i].current_brust_time = processes[i].phases[processes[i].phase_idx].first;
            waiting.push(i);
            i++;
        }
        for(idx_p =0 ;idx_p<4;idx_p++)
        {
            if(processor[idx_p]==-1) // means that , that processor is ideal
            {
                output[t][idx_p]="i";
                if(!waiting.empty())
                {
                    WillGoToTheQ[idx_p]=waiting.top();
                    waiting.pop();
                }
                continue;
            }
            pr = processor[idx_p];  // index of the process in the processor
            output[t][idx_p]=processes[pr].process_name;
            processes[pr].time_consumed++;
            if(processes[pr].time_consumed == processes[pr].current_brust_time) // proceses finished exec
            {
                processes[pr].phase_idx++;
                processes[pr].time_consumed=0;
                if(processes[pr].phase_idx < processes[pr].n_phases) // still want more ?
                {
                    processes[pr].state = processes[pr].phases[processes[pr].phase_idx].second;
                    processes[pr].current_brust_time = processes[pr].phases[processes[pr].phase_idx].first;
                }
                else //process finished
                {
                    finished_processes++;
                    processes[pr].state=2;
                    processes[pr].complete_time=t;
                    processes[pr].turn_around_time = t - processes[pr].arrive_time;
                }
                if (!waiting.empty())
                {
                    WillGoToTheQ[idx_p] = waiting.top();
                    waiting.pop();
                }
                processor[idx_p]=-1;
            }

        }
        match_prefrences(processor,WillGoToTheQ,processes);
        IO_handler_bypq(size,processes,waiting,finished_processes,t);

        if (finished_processes == size)
        {
            print(t);
            return;
        }

    }
}

/*void replace_process(int * processor ,priority_queue<int,vector<int>,CompareProcess> &my_queue,process processes[])
{
    for(int i=0;i<4;i++)
    {
           int waiting_process_current_time_left= processes[my_queue.top()].current_brust_time - processes[my_queue.top()].time_consumed;
           int running_process_time_left= processes[processor[i]].current_brust_time - processes[processor[i]].time_consumed;
           if(waiting_process_current_time_left < running_process_time_left) // u will switch between process on cpu with process on waiting
           {
               my_queue.push(processor[i]);
               processor[i]=my_queue.top();
               my_queue.pop();
               break;
           }
    }
}*/
void STCF(int size,process processes [])
{
    sort(processes,processes+size, comparedByBurst);
    int finished_processes=0,processor[4],WillGoToTheQ[4],i=0,pr;
    memset(processor,-1,sizeof processor);
    memset(WillGoToTheQ,-1,sizeof WillGoToTheQ);
    CompareProcess cmp (processes);
    priority_queue<int,vector<int>,CompareProcess>waiting(cmp);
    for(int t=0;;t++)
    {
        int idx_p=0;
        for (idx_p = 0; idx_p < 4 && i < size && processes[i].arrive_time <= t; ++idx_p) // if processor is ideal and processes
        {
            if (processor[idx_p] == -1)
            {
                processor[idx_p] = i;
                processes[i].current_brust_time = processes[i].phases[processes[i].phase_idx].first;
                processes[i].state = processes[i].phases[processes[i].phase_idx].second;
                processes[i].last_processor = idx_p;
                i++;
            }
            /* else // some process is at cpu right now
              {
                  int waiting_process_current_time_left= processes[i].phases[processes[i].phase_idx].first;
                  int running_process_time_left= processes[processor[idx_p]].current_brust_time - processes[processor[idx_p]].time_consumed;
                  if(waiting_process_current_time_left < running_process_time_left)
                  {
                      waiting.push(processor[idx_p]);
                      processes[i].current_brust_time=processes[i].phases[processes[i].phase_idx].first;
                      processes[i].state = processes[i].phases[processes[i].phase_idx].second;
                      processes[i].last_processor = idx_p;
                      processor[idx_p]=i;
                  }
                  else
                  {
                      processor[idx_p] = i;
                      processes[i].current_brust_time = processes[i].phases[processes[i].phase_idx].first;
                      processes[i].state = processes[i].phases[processes[i].phase_idx].second;
                      processes[i].last_processor = idx_p;
                  }
                  i++;
              }*/
        }
        int replace=0;
        while(i<size && processes[i].arrive_time <=t ) // processes arrived but there is no place at cpu so it will go in waiting queue
        {

            processes[i].state = processes[i].phases[processes[i].phase_idx].second;
            processes[i].current_brust_time = processes[i].phases[processes[i].phase_idx].first;
            waiting.push(i);
            i++;
            /*if(replace < 4)
                replace_process(processor,waiting,processes),replace++;*/
            for(int q=0;q<4;q++)
            {
                if(processor[q]!= -1)
                {
                    waiting.push(processor[q]);
                }
            }
            for(int q=0;q<4;q++)
            {
                processor[q]=waiting.top();
                waiting.pop();
            }
        }

        for(idx_p =0 ;idx_p<4;idx_p++)
        {
            if(processor[idx_p]==-1) // means that , that processor is ideal
            {
                output[t][idx_p]="i";
                if(!waiting.empty())
                {
                    WillGoToTheQ[idx_p]=waiting.top();
                    waiting.pop();
                }
                continue;
            }
            pr = processor[idx_p];  // index of the process in the processor
            output[t][idx_p]=processes[pr].process_name;
            processes[pr].time_consumed++;
            if(processes[pr].time_consumed == processes[pr].current_brust_time) // proceses finished exec
            {
                processes[pr].phase_idx++;
                processes[pr].time_consumed=0;
                if(processes[pr].phase_idx < processes[pr].n_phases) // still want more ?
                {
                    processes[pr].state = processes[pr].phases[processes[pr].phase_idx].second;
                    processes[pr].current_brust_time = processes[pr].phases[processes[pr].phase_idx].first;
                }
                else //process finished
                {
                    finished_processes++;
                    processes[pr].state=2;
                    processes[pr].complete_time=t;
                    processes[pr].turn_around_time = t - processes[pr].arrive_time;
                }
                if (!waiting.empty())
                {
                    WillGoToTheQ[idx_p] = waiting.top();
                    waiting.pop();
                }
                processor[idx_p]=-1;
            }

        }
        match_prefrences(processor,WillGoToTheQ,processes);
        IO_handler_bypq(size,processes,waiting,finished_processes,t);

        if (finished_processes == size)
        {
            print(t);
            return;
        }
    }
}

// use this two lines
//CompareProcesspriority cmp (processes);
//    priority_queue<int,vector<int>,CompareProcesspriority>waiting(cmp);
/*
void print_turnaround(n,process processes[])
{
    for(int i=0;i<n;i++)
    {
        cout<<"Turn Around Time for process" <<processes[i].process_name<<" : "<<processes[i].turn_around_time<<endl;
    }
}*/
int main() {

    int n;
    cout<<"enter number of process\n";
    cin >> n;
    process processes[n];
    Input(n, processes);
    SJF(n,processes);

    return 0;

}
/*
 *
 * 5
A 2 0
3 EXE
2 I/O
B 3 1
4 EXE
2 I/O
3 EXE
C 2 2
5 EXE
1 I/O
D 2 3
2 EXE
4 I/O
E 3 4
3 EXE
1 I/O
2 EXE
 * */

/*
 *
 *
7
A 4 0
3 EXE
2 I/O
20 EXE
1 I/O

B 3 0
6 EXE
2 I/O
1 EXE

C 3 0
10 EXE
2 I/O
10 EXE

D 3 0
6 EXE
3 I/O
6 EXE

E 3 0
6 EXE
3 I/O
6 EXE

F 3 0
6 EXE
3 I/O
6 EXE

X 3 2
1 EXE
1 I/O
10 EXE
 */
